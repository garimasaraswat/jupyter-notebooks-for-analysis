* TODO

1. calculation state functions
2. calculation required
3. calculation restart
  a. Reading calculation in

* ase + Vasp



** co example
#+BEGIN_SRC python
from ase import Atoms, Atom
from vasp import Vasp
import logging
import os
#os.environ['ASE_VASP_COMMAND'] = '/home-research/zhongnanxu/opt/vasp-5.3.5/bin/vasp-vtst-beef-serial'

#os.system('rm -fr molecules/simple-co')

co = Atoms([Atom('C',[0,   0, 0]),
            Atom('O',[1.2, 0, 0])],
            cell=(6., 6., 6.))

calc = Vasp('molecules/simple-co', #output dir
            xc='PBE',  # the exchange-correlation functional
            nbands=6,  # number of bands
            encut=350, # planewave cutoff
            ismear=1,  # Methfessel-Paxton smearing
            sigma=0.01,# very small smearing factor for a molecule
            debug=logging.DEBUG,
            atoms=co)

print calc.get_potential_energy()

from ase.visualize import view
view(co)
#print a.get_magnetic_moments()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calc = Vasp('molecules/simple-co')

from ase.visualize import view
view(calc.get_atoms())
#+END_SRC

#+RESULTS:

** co2
#+BEGIN_SRC python
from ase import Atoms, Atom
from vasp import Vasp

import os
os.environ['ASE_VASP_COMMAND'] = '/home-research/zhongnanxu/opt/vasp-5.3.5/bin/vasp-vtst-beef-serial'

#os.system('rm -fr molecules/co2')

atoms = Atoms([Atom('O',[4, 5, 5]),
               Atom('C',[5,   5, 5]),
               Atom('O',[6, 5, 5])],
              cell=(10, 10, 10))

calc = Vasp('molecules/co2', #output dir
            xc='PBE',  # the exchange-correlation functional
            encut=350, # planewave cutoff
            ibrion=1, nsw=2,
            atoms=atoms)

print 'p1: \n',atoms.positions
print atoms.get_potential_energy()
print 'p2: \n',atoms.positions

print 'f: ',atoms.get_forces()
#+END_SRC

#+RESULTS:
#+begin_example
p1:
[[ 2.47829296  5.          5.        ]
 [ 5.          5.          5.        ]
 [ 7.52170704  5.          5.        ]]
-4.35577086
p2:
[[ 2.478293  5.        5.      ]
 [ 5.        5.        5.      ]
 [ 7.521707  5.        5.      ]]
f:  [[ 2.47499768  0.          0.        ]
 [ 0.          0.          0.        ]
 [-2.47499768  0.          0.        ]]
#+end_example

#+BEGIN_SRC sh
rm -fr molecules/co2/*
#+END_SRC

#+RESULTS:

** co
#+BEGIN_SRC python
from ase import Atoms, Atom
from vasp import Vasp

import os
os.environ['ASE_VASP_COMMAND'] = '/home-research/zhongnanxu/opt/vasp-5.3.5/bin/vasp-vtst-beef-serial'

#os.system('rm -fr molecules/co')

atoms = Atoms([Atom('C', [4.42,   5., 5.]),
               Atom('O', [5.58,   5., 5.])],
              cell=[10, 10, 10])

print atoms.positions
calc = Vasp('molecules/co', #output dir
            xc='PBE',  # the exchange-correlation functional
            encut=350, # planewave cutoff
            ibrion=2, nsw=10,
            atoms=atoms)


print atoms.get_potential_energy()
print atoms.positions
print 'f: \n', atoms.get_forces()
#+END_SRC

#+RESULTS:
: [[ 4.42  5.    5.  ]
:  [ 5.58  5.    5.  ]]
: -14.80857838
: [[ 4.4289913  5.         5.       ]
:  [ 5.5710087  5.         5.       ]]
: f:
: [[-0.20633627  0.          0.        ]
:  [ 0.20633627  0.          0.        ]]

#+BEGIN_SRC python
a = '3'
print float(a)
#+END_SRC

#+RESULTS:
: 3.0
** read incar
At some point we need logic on whether parameters have changed. We work out some of this here for the incar.

Here is how to compare parameter sets.
#+BEGIN_SRC python
from vasp import Vasp
calc = Vasp('molecules/co')
print calc.parameters
print calc.default_parameters
print calc.parameters == calc.default_parameters
#+END_SRC

#+RESULTS:
: {'kpts': [1, 1, 1], 'ismear': 1, 'lcharge': False, 'xc': 'PBE', 'lwave': False, 'sigma': 0.1, 'pp': 'PBE'}
: {'kpts': [1, 1, 1], 'ismear': 1, 'lcharge': False, 'xc': 'PBE', 'lwave': False, 'sigma': 0.1, 'pp': 'PBE'}
: True

The read_incar function gets the parameters from the incar.
#+BEGIN_SRC python
from vasp import Vasp
calc = Vasp('molecules/co')
print calc.read_incar()
#+END_SRC

#+RESULTS:
: {'magmoms': [1.0, -1], 'lcharge': False, 'encut': 350, 'ibrion': 2, 'ismear': 1, 'lwave': False, 'sigma': 0.1, 'nsw': 'free'}

Now, the challenge is to see what has changed. When we read things in, and kwargs is empty, we have to assume what is in the files is correct.


Let's get the tags in the default_parameters
#+BEGIN_SRC python
from vasp import Vasp
calc = Vasp('molecules/co')
ip = calc.read_incar()
print {key: val  for key,val in ip.iteritems() if key in calc.default_parameters}

default_incar_parameters = {key: val for key, val
                            in Vasp.default_parameters.iteritems()
                            if key not in Vasp.special_kwargs}

print default_incar_parameters
print calc.kwargs
#+END_SRC

#+RESULTS:
: {'ismear': 1, 'lwave': False, 'sigma': 0.1, 'lcharge': False}
: {'ismear': 1, 'lwave': False, 'sigma': 0.1, 'lcharge': False}
: {}

** testing incar params

#+BEGIN_SRC python
from ase import Atoms, Atom
from vasp import Vasp

import os
os.environ['ASE_VASP_COMMAND'] = '/home-research/zhongnanxu/opt/vasp-5.3.5/bin/vasp-vtst-beef-serial'

#os.system('rm -fr molecules/co')

atoms = Atoms([Atom('C', [4.42,   5., 5.]),
               Atom('O', [5.58,   5., 5.])],
              cell=[10, 10, 10])

print atoms.positions
calc = Vasp('molecules/co', #output dir
            xc='PBE',  # the exchange-correlation functional
            encut=350, # planewave cutoff
            ibrion=2, nsw=10,
            atoms=atoms)
print calc.parameters
print calc.read_incar()
#+END_SRC

#+RESULTS:
: [[ 4.42  5.    5.  ]
:  [ 5.58  5.    5.  ]]
: {'kpts': [1, 1, 1], 'lcharge': False, 'xc': 'PBE', 'pp': 'PBE', 'encut': 350, 'ibrion': 2, 'ismear': 1, 'lwave': False, 'sigma': 0.1, 'nsw': 10}
: {'magmoms': [1.0, -1], 'lcharge': False, 'encut': 350, 'ibrion': 2, 'ismear': 1, 'lwave': False, 'sigma': 0.1, 'nsw': 'free'}

** test reading kpoints
#+BEGIN_SRC python
from ase import Atoms, Atom
from vasp import Vasp

import os
os.environ['ASE_VASP_COMMAND'] = '/home-research/zhongnanxu/opt/vasp-5.3.5/bin/vasp-vtst-beef-serial'

#os.system('rm -fr molecules/co')

atoms = Atoms([Atom('C', [4.42,   5., 5.]),
               Atom('O', [5.58,   5., 5.])],
              cell=[10, 10, 10])

print atoms.positions
calc = Vasp('molecules/co', #output dir
            xc='PBE',  # the exchange-correlation functional
            encut=350, # planewave cutoff
            ibrion=2, nsw=10,
            atoms=atoms)
print calc.parameters
print calc.read_kpoints()
#+END_SRC

#+RESULTS:
: [[ 4.42  5.    5.  ]
:  [ 5.58  5.    5.  ]]
: {'kpts': [1, 1, 1], 'lcharge': False, 'xc': 'PBE', 'pp': 'PBE', 'encut': 350, 'ibrion': 2, 'ismear': 1, 'lwave': False, 'sigma': 0.1, 'nsw': 10}
: {'kpts': [1, 1, 1]}

** Read POTCAR
#+BEGIN_SRC python
from ase import Atoms, Atom
from vasp import Vasp

import os
os.environ['ASE_VASP_COMMAND'] = '/home-research/zhongnanxu/opt/vasp-5.3.5/bin/vasp-vtst-beef-serial'

#os.system('rm -fr molecules/co')

atoms = Atoms([Atom('C', [4.42,   5., 5.]),
               Atom('O', [5.58,   5., 5.])],
              cell=[10, 10, 10])

print atoms.positions
calc = Vasp('molecules/co', #output dir
            xc='PBE',  # the exchange-correlation functional
            encut=350, # planewave cutoff
            ibrion=2, nsw=10, setups=[['O', '_s']],
            atoms=atoms)
print calc.write_input(atoms)

p = {}
p.update(calc.read_incar())
p.update(calc.read_kpoints())
p.update(calc.read_potcar())

print p
print calc.parameters
#+END_SRC

#+RESULTS:
: [[ 4.42  5.    5.  ]
:  [ 5.58  5.    5.  ]]
: None
: {'kpts': [1, 1, 1], 'ibrion': 2, 'lcharge': False, 'setups': [['O', '_s']], 'ismear': 1, 'lwave': False, 'sigma': 0.1, 'pp': 'PBE', 'encut': 350, 'nsw': 10}
: {'kpts': [1, 1, 1], 'xc': 'PBE', 'encut': 350, 'ibrion': 2, 'ismear': 1, 'nsw': 10, 'pp': 'PBE', 'lcharge': False, 'setups': [['O', '_s']], 'lwave': False, 'sigma': 0.1}


** the xc issue
Since we allow xc to expand to a set of tags, we do not have a great way yet to identify what xc is. We can try pattern matching, but it is tricky. Each xc is a dictionary, and the order of keys is arbitrary. So, we need to match patterns, by longest first.

#+BEGIN_SRC python
from vasp import Vasp
print Vasp.xc_defaults
#+END_SRC

#+RESULTS:
: {'optb86b-vdw': {'pp': 'LDA', 'aggac': 0.0, 'gga': 'MK', 'param2': 1.0, 'param1': 0.1234, 'luse_vdw': True}, 'lda': {'pp': 'LDA'}, 'm06l': {'pp': 'PBE', 'metagga': 'M06L'}, 'hf': {'aldac': 0.0, 'aggac': 0.0, 'pp': 'PBE', 'aexx': 1.0, 'lhfcalc': True}, 'beef-vdw': {'zab_vdw': -1.8867, 'pp': 'LDA', 'gga': 'BF', 'luse_vdw': True}, 'optpbe-vdw': {'pp': 'LDA', 'gga': 'OR', 'luse_vdw': True, 'aggac': 0.0}, 'revtpss': {'pp': 'PBE', 'metagga': 'RTPSS'}, 'b3lyp': {'pp': 'LDA', 'aggac': 0.81, 'aldac': 0.19, 'aexx': 0.2, 'gga': 'B3', 'lhfcalc': True, 'aggax': 0.72}, 'pbe': {'pp': 'PBE'}, 'rpbe': {'pp': 'LDA', 'gga': 'RP'}, 'tpss': {'pp': 'PBE', 'metagga': 'TPSS'}, 'optb88-vdw': {'pp': 'LDA', 'aggac': 0.0, 'gga': 'BO', 'param2': 0.22, 'param1': 0.18333333333333335, 'luse_vdw': True}, 'hse03': {'pp': 'LDA', 'gga': 'PE', 'hfscreen': 0.3, 'lhfcalc': True}, 'vdw-df2': {'zab_vdw': -1.8867, 'pp': 'LDA', 'gga': 'ML', 'luse_vdw': True, 'aggac': 0.0}, 'pbesol': {'pp': 'LDA', 'gga': 'PS'}, 'am05': {'pp': 'LDA', 'gga': 'AM'}, 'revpbe': {'pp': 'LDA', 'gga': 'RE'}, None: {'pp': 'PBE'}}

#+BEGIN_SRC python
from vasp import Vasp
# Sort keys by largest number of options
exc = sorted(Vasp.xc_defaults, key=lambda k: len(Vasp.xc_defaults[k]), reverse=True)
print k
#+END_SRC

#+RESULTS:
: ['b3lyp', 'optb86b-vdw', 'optb88-vdw', 'hf', 'vdw-df2', 'beef-vdw', 'optpbe-vdw', 'hse03', 'm06l', 'revtpss', 'rpbe', 'tpss', 'pbesol', 'am05', 'revpbe', 'lda', 'pbe', None]

To determine which functional is used, I need to get all the options for a functional, and compare them to the subset of options in a calculation.

#+BEGIN_SRC python
from ase import Atoms, Atom
from vasp import Vasp

import os
os.environ['ASE_VASP_COMMAND'] = '/home-research/zhongnanxu/opt/vasp-5.3.5/bin/vasp-vtst-beef-serial'

#os.system('rm -fr molecules/co')

atoms = Atoms([Atom('C', [4.42,   5., 5.]),
               Atom('O', [5.58,   5., 5.])],
              cell=[10, 10, 10])

print atoms.positions
calc = Vasp('molecules/co', #output dir
            xc='PBE',  # the exchange-correlation functional
            encut=350, # planewave cutoff
            ibrion=2, nsw=10,
            atoms=atoms)
calc.write_input(atoms)
print calc.parameters
print calc.read()

print calc.parameters == calc.read()[1]
#+END_SRC

#+RESULTS:
: [[ 4.42  5.    5.  ]
:  [ 5.58  5.    5.  ]]
: {'kpts': [1, 1, 1], 'lcharge': False, 'xc': 'pbe', 'pp': 'PBE', 'encut': 350, 'ibrion': 2, 'ismear': 1, 'lwave': False, 'sigma': 0.1, 'nsw': 10}
: (Atoms(symbols='CO', positions=..., cell=[10.0, 10.0, 10.0], pbc=[True, True, True]), {'pp': 'PBE', 'ibrion': 2, 'xc': 'pbe', 'lcharge': False, 'ismear': 1, 'lwave': False, 'sigma': 0.1, 'kpts': [1, 1, 1], 'encut': 350, 'nsw': 10})
: True





* Test reads
#+BEGIN_SRC python
from vasp import Vasp

calc = Vasp('~/dft-book-new-vasp/molecules/simple-co')


#print(calc.potential_energy)
#+END_SRC

#+RESULTS:
: {'magmom': 0, 'magmoms': array([ 0.,  0.]), 'energy': -14.69111507, 'stress': array([ 0.04145558,  0.0109497 ,  0.0109497 , -0.        , -0.        , -0.        ]), 'forces': array([[ 5.09138064,  0.        ,  0.        ],
:        [-5.09138064,  0.        ,  0.        ]])}

#+BEGIN_SRC python
from vasp import Vasp

calc = Vasp('~/dft-book-new-vasp/molecules/nh3-neb')
print calc.results
print calc.neb
#+END_SRC

#+RESULTS:
: Reading neb
: {'energy': None}
: [Atoms(symbols='NH3', positions=..., cell=[10.0, 10.0, 10.0], pbc=[True, True, True], constraint=FixAtoms(indices=[0])), Atoms(symbols='NH3', positions=..., cell=[10.0, 10.0, 10.0], pbc=[True, True, True], constraint=FixAtoms(indices=[0])), Atoms(symbols='NH3', positions=..., cell=[10.0, 10.0, 10.0], pbc=[True, True, True], constraint=FixAtoms(indices=[0])), Atoms(symbols='NH3', positions=..., cell=[10.0, 10.0, 10.0], pbc=[True, True, True], constraint=FixAtoms(indices=[0])), Atoms(symbols='NH3', positions=..., cell=[10.0, 10.0, 10.0], pbc=[True, True, True], constraint=FixAtoms(indices=[0]))]

* ase-db test

#+BEGIN_SRC python
from vasp import Vasp
import shutil
import os

calc = Vasp('~/dft-book-new-vasp/molecules/simple-co')
atoms = calc.get_atoms()
from ase.db import connect

try:
    shutil.copyfile('ase.db', 'ase.db.bk')
    os.unlink('ase.db')
    con = connect('ase.db')
    con.write(atoms, running=True, data={'resort': calc.resort})
except:
    print 'caught exc'
    os.unlink('ase.db')
    shutil.copyfile('ase.db.bk', 'ase.db')
finally:
    os.unlink('ase.db.bk')

for x in con.select(): print x

c = con.get(id=1)
print c.data
print 'c', con.update(1, delete_keys=['running'])

print con.get_atoms(id=1, add_additional_information=True).info

#+END_SRC

#+RESULTS:
: {}
: <ase.db.row.AtomsRow instance at 0x8fdefc8>
: {u'resort': array([0, 1])}
: c (0, 1)
: {'data': {u'resort': array([0, 1])}, 'key_value_pairs': {u'running': True}, 'unique_id': u'4fd1a4085307494d4c2d0a52e3c6270c'}

#+BEGIN_SRC sh
ase-db ase.db
#+END_SRC

#+RESULTS:
: id|age|user    |formula|calculator| energy| fmax|pbc| volume|charge|  mass| smax|magmom
:  1| 2s|jkitchin|CO     |vasp      |-14.687|5.091|TTT|216.000| 0.000|28.010|0.041| 0.000
: Rows: 1
: Keys: running

#+BEGIN_SRC python
import ase.io
atoms = ase.io.read('ase.db')
print atoms.get_potential_energy()
#+END_SRC

#+RESULTS:
: -14.6872498

** try deleting a key
#+BEGIN_SRC python
from vasp import Vasp
import shutil
import os

calc = Vasp('~/dft-book-new-vasp/molecules/simple-co')
atoms = calc.get_atoms()
from ase.db import connect

con = connect('ase.db')
con.write(atoms, running=True, data={'resort': calc.resort})
print con.get_atoms(id=1, add_additional_information=True).info
print 'c', con.update(1, delete_keys=['running'])

#with connect('ase.db') as con:
#    print con.get_atoms(id=1, add_additional_information=True).info

#+END_SRC

#+RESULTS:
: {'data': {u'resort': array([0, 1])}, 'key_value_pairs': {u'running': True}, 'unique_id': u'2e247d1223ccc111f254ab73f41672a1'}
: c (0, 1)

** write atoms with info does not work  like I expect
I had hoped to get an atoms with info and just write it back, but it does not seem possible. Here is the way to do this. Note that append=False creates a new database each time.

#+BEGIN_SRC python
from vasp import Vasp
import shutil
import os

calc = Vasp('~/dft-book-new-vasp/molecules/simple-co')
atoms = calc.get_atoms()

from ase.db import connect

with connect('abc.db', append=False) as con:
    print con.write(atoms, relaxed=True, data={'resort': calc.resort, 'running': True})

atoms2 = con.get_atoms(id=1, add_additional_information=True)
atoms2.info['data']['running']=False
print atoms2.info
con.write(atoms2, data=atoms2.info['data'], **atoms2.info['key_value_pairs'])
#+END_SRC

#+RESULTS:
: 1
: {'data': {u'resort': array([0, 1]), u'running': False}, 'key_value_pairs': {u'relaxed': True}, 'unique_id': u'e032fa3de495b66e0e1d891a5e257fc9'}

#+BEGIN_SRC sh
ase-db abc.db
#+END_SRC

#+RESULTS:
: id|age|user    |formula|calculator| energy| fmax|pbc| volume|charge|  mass| smax|magmom
:  1| 8s|jkitchin|CO     |vasp      |-14.691|5.091|TTT|216.000| 0.000|28.010|0.041| 0.000
:  2| 8s|jkitchin|CO     |vasp      |-14.691|5.091|TTT|216.000| 0.000|28.010|0.041| 0.000
: Rows: 2
: Keys: relaxed


#+BEGIN_SRC python
from ase.db import connect
con = connect('abc.db')

print con.get_atoms(id=2, add_additional_information=True).info
#+END_SRC

#+RESULTS:
: {'data': {u'resort': array([0, 1]), u'running': False}, 'key_value_pairs': {u'relaxed': True}, 'unique_id': u'9394e16ea478ec5c87de4a724da43f08'}

* An approach to update row 1 in an ase-db

First we create an entry.
#+BEGIN_SRC python
from vasp import Vasp
import shutil
import os

calc = Vasp('~/dft-book-new-vasp/molecules/simple-co')
atoms = calc.get_atoms()

from ase.db import connect

with connect('abc.db', append=False) as con:
    print con.write(atoms, relaxed=True, data={'resort': calc.resort, 'running': True})
#+END_SRC

#+RESULTS:
: 1

#+BEGIN_SRC sh
ase-db abc.db
#+END_SRC

#+RESULTS:
: id|age|user    |formula|calculator| energy| fmax|pbc| volume|charge|  mass| smax|magmom
:  1| 3s|jkitchin|CO     |vasp      |-14.691|5.091|TTT|216.000| 0.000|28.010|0.041| 0.000
: Rows: 1
: Keys: relaxed

To get the atoms we do this. We cannot use append=False here because it seems to delete the db right away. We modify some key-value pairs, update the data, and the positions.

#+BEGIN_SRC python
from ase.db import connect

with connect('abc.db') as con:
    atoms = con.get_atoms(id=1, add_additional_information=True)

atoms.positions = [[0, 0, 0], [1.5, 0, 0]]
atoms.cell = (9, 9, 9)

data = atoms.info['data']
kv = atoms.info['key_value_pairs']

del kv['relaxed']
kv['status'] = 'finished'

data['running'] = False

with connect('abc.db', append=False) as con:
    print con.write(atoms, data=data, **kv)
#+END_SRC

#+RESULTS:
: 1

#+BEGIN_SRC python
from ase.db import connect

with connect('abc.db') as con:
    atoms = con.get_atoms(id=1, add_additional_information=True)

print atoms.info
#+END_SRC

#+RESULTS:
: {'data': {u'resort': array([0, 1]), u'running': False}, 'key_value_pairs': {u'status': u'finished'}, 'unique_id': u'b07e2f4f43ca475537fd4846c3d48019'}

#+BEGIN_SRC sh
ase-db abc.db id=1 -l
#+END_SRC

#+RESULTS:
#+begin_example
name      |unit  |value
id        |      |1
age       |      |10.658 seconds
formula   |      |CO
user      |      |jkitchin
calculator|      |vasp
charge    ||e|   |0.0
mass      |au    |28.0104
unique id |      |b07e2f4f43ca475537fd4846c3d48019
volume    |Ang^3 |729.0

Unit cell in Ang:
axis|periodic|          x|          y|          z
   1|     yes|      9.000|      0.000|      0.000
   2|     yes|      0.000|      9.000|      0.000
   3|     yes|      0.000|      0.000|      9.000

Key-value pairs:
status|finished

Data: resort, running
#+end_example

It looks like things have been updated.



* Using Vasp.write_db

#+BEGIN_SRC python
from vasp import Vasp

calc = Vasp('~/dft-book-new-vasp/molecules/simple-co')
atoms = calc.get_atoms()

calc.write_db(data={'resort': calc.resort},
              jobid='123.gilgameshe.cheme.cmu.edu')
#+END_SRC

#+RESULTS:

# Now
#+BEGIN_SRC python
import os
from vasp import Vasp

calc = Vasp('~/dft-book-new-vasp/molecules/simple-co')

from ase.db import connect
with connect(os.path.join(calc.directory, 'DB.db')) as con:
    at = con.get(id=1)

    print at.key_value_pairs.get('jobid', None)


print calc.get_db_kv('jobid')
print calc.get_db_data('resort')
print calc.get_db('jobid')
print calc.get_db('resort')

jobid, resort = calc.get_db('jobid', 'resort')
print jobid, resort
#+END_SRC

#+RESULTS:
: 123.gilgameshe.cheme.cmu.edu
: 123.gilgameshe.cheme.cmu.edu
: [0 1]
: 123.gilgameshe.cheme.cmu.edu
: [0 1]
: 123.gilgameshe.cheme.cmu.edu [0 1]

Now we can delete a key like this, by setting jobid to None
#+BEGIN_SRC python
import os
from vasp import Vasp

calc = Vasp('~/dft-book-new-vasp/molecules/simple-co')

calc.write_db(jobid=None)

from ase.db import connect
with connect(os.path.join(calc.directory, 'DB.db')) as con:
    at = con.get(id=1)

    print at.key_value_pairs.get('jobid', None)
    print at.data



#+END_SRC

#+RESULTS:
: None
: {u'resort': array([0, 1])}



#+BEGIN_SRC python
from ase.db import connect

with connect('ase.db') as con2:
    print 'c', con2.update(1, delete_keys=['running'])
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from ase.db import connect

with connect('ase.db') as con:
    print con.get_atoms(id=1, add_additional_information=True).info
#+END_SRC

#+RESULTS:
: {'data': {u'resort': array([0, 1])}, 'key_value_pairs': {u'running': True}, 'unique_id': u'4fd1a4085307494d4c2d0a52e3c6270c'}



#+BEGIN_SRC sh
ase-db ase.db
#+END_SRC

#+RESULTS:
#+begin_example
id| age|user    |formula|calculator| energy| fmax|pbc| volume|charge|  mass| smax|magmom
 1| 20h|jkitchin|CO     |vasp      |-14.687|5.091|TTT|216.000| 0.000|28.010|0.041| 0.000
 2|264s|jkitchin|CO     |vasp      |-14.687|5.091|TTT|216.000| 0.000|28.010|0.041| 0.000
 3|256s|jkitchin|CO     |vasp      |-14.687|5.091|TTT|216.000| 0.000|28.010|0.041| 0.000
 4|252s|jkitchin|CO     |vasp      |-14.687|5.091|TTT|216.000| 0.000|28.010|0.041| 0.000
 5|247s|jkitchin|CO     |vasp      |-14.687|5.091|TTT|216.000| 0.000|28.010|0.041| 0.000
 6|243s|jkitchin|CO     |vasp      |-14.687|5.091|TTT|216.000| 0.000|28.010|0.041| 0.000
 7|222s|jkitchin|CO     |vasp      |-14.687|5.091|TTT|216.000| 0.000|28.010|0.041| 0.000
 8|203s|jkitchin|CO     |vasp      |-14.687|5.091|TTT|216.000| 0.000|28.010|0.041| 0.000
 9|194s|jkitchin|CO     |vasp      |-14.687|5.091|TTT|216.000| 0.000|28.010|0.041| 0.000
10|157s|jkitchin|CO     |vasp      |-14.687|5.091|TTT|216.000| 0.000|28.010|0.041| 0.000
11|153s|jkitchin|CO     |vasp      |-14.687|5.091|TTT|216.000| 0.000|28.010|0.041| 0.000
Rows: 11
Keys: running
#+end_example

* archive
** stuff

#+BEGIN_SRC python
from vasp import *

calc = Vasp('simple-co',
            encut=400,
            xc='beef-vdw',
            setups={'H': '_sv'},
            ldaul=(-1, 2),
            ldauu=[0, 0.2],
            ldauj=[0, 0.00],  kpts=(10, 10, 10))

# print dir(calc)
print calc.parameters
#print calc.special_kwargs
#print list(set(calc.parameters) - set(calc.special_kwargs))
#print {key: calc.parameters[key] for key in list(set(calc.parameters) - set(calc.special_kwargs))}
#calc.write_input(None)

#print open('simple-co/INCAR').read()

#print open('simple-co/KPOINTS').read()
#+END_SRC

#+RESULTS:
: {'kpts': (10, 10, 10), 'lcharge': False, 'xc': 'beef-vdw', 'ldaul': (-1, 2), 'ldauj': [0, 0.0], 'encut': 400, 'ldauu': [0, 0.2], 'gga': 'BF', 'zab_vdw': -1.8867, 'setups': {'H': '_sv'}, 'lwave': False, 'sigma': 0.1, 'luse_vdw': True}

#+BEGIN_SRC python
from vasp import *
from ase import Atom, Atoms

atoms = Atoms([Atom('O', [4, 4.5, 5], magmom=2),
               Atom('O', [4, 4.5, 5], magmom=2),
               Atom('H', [4, 4.5, 15], magmom=2),
               Atom('O', [4, 4.5, 25], magmom=2)],
              cell=(8, 9, 10))

calc = Vasp('molecules/O-sp-triplet-lowsym-sv',
          xc='pbe',
          ismear=0,
          ispin=2,
          sigma=0.01,
          setups={0: 'O_pv', 'O':'_sv'},
          atoms=atoms)


#+END_SRC

#+RESULTS:

I should get this.
: ['potpawPBE/O_pv/POTCAR', 'potpawPBE/O_sv/POTCAR', 'potpawPBE/H/POTCAR']


** Handling setups.
In VASP we have to create the POTCAR file by concatenating existing POTCAR files for each atom into a single file. There are several options for how to do this.

1. Each atom can have its own POTCAR.
2. Common atoms can be grouped to share a POTCAR




#+BEGIN_SRC python
from vasp import *
from ase import Atom, Atoms

atoms = Atoms([Atom('O', [4, 4.5, 5], magmom=2),
               Atom('O', [4, 4.5, 5], magmom=2),
               Atom('H', [4, 4.5, 15], magmom=2),
               Atom('O', [4, 4.5, 25], magmom=2)],
              cell=(8, 9, 10))

setups = [[3, '_pv'], ['O', '_sv']]

pp = 'PBE'

# goal:
# pp = [(3 ,'potpawPBE/O_pv/POTCAR', 1)
#       ('O', 'potpawPBE/O_sv/POTCAR', 2),
#       ('H', 'potpawPBE/H/POTCAR', 1)]
# sort_indices = [3, 0, 1, 2]
ppp = []
sort_indices = []

# First the numeric setups
for setup in [x for x in setups if isinstance(x[0], int)]:
    ppp += [[setup[0],
             'potpaw_{}/{}{}/POTCAR'.format(pp, atoms[setup[0]].symbol, setup[1]),
             1]]
    sort_indices += [setup[0]]

# now the rest of the setups. These are atom symbols
for setup in [x for x in setups if not isinstance(x[0], int)]:
    symbol = setup[0]
    count = 0
    for i, atom in enumerate(atoms):
        if atom.symbol == symbol and i not in sort_indices:
            count += 1
            sort_indices += [i]
    ppp += [[atom.symbol,
             'potpaw_{}/{}{}/POTCAR'.format(pp, symbol, setup[1]),
             count]]

# now the remaining atoms use default potentials
symbols = []
for atom in atoms:
    if atom.symbol not in symbols and atom.symbol not in [x[0] for x in pp]:
        symbols += [atom.symbol]

for symbol in symbols:
    count = 0
    for i, atom in enumerate(atoms):
        if atom.symbol == symbol and i not in sort_indices:
            sort_indices += [i]
            count += 1
    ppp += [[symbol,
             'potpaw_{}/{}/POTCAR'.format(pp, symbol),
             count]]


print symbols
print ppp
print sort_indices


#+END_SRC

#+RESULTS:
: ['O', 'H']
: [[3, 'potpaw_PBE/O_pv/POTCAR', 1], ['O', 'potpaw_PBE/O_sv/POTCAR', 2], ['O', 'potpaw_PBE/O/POTCAR', 0], ['H', 'potpaw_PBE/H/POTCAR', 1]]
: [3, 0, 1, 2]


#+BEGIN_SRC python
from vasp import Vasp
from ase import Atom, Atoms

atoms = Atoms([Atom('O', [4, 4.5, 0], magmom=2),
               Atom('O', [4, 4.5, 1], magmom=2),
               Atom('H', [4, 4.5, 2], magmom=2),
               Atom('O', [4, 4.5, 3], magmom=2)],
              cell=(8, 9, 10))

calc = Vasp('molecules/O-sp-triplet-lowsym-sv',
          xc='pbe',
          ismear=0,
          ispin=2,
          sigma=0.01,
          setups=[[1, '_h'], ['O', '_sv']],
          atoms=atoms)

print calc.sort_indices
print calc.ppp_list
#print calc.atoms_sorted
#print calc.symbol_count

calc.write_poscar('POSCAR')
calc.write_potcar('POTCAR')
#+END_SRC

#+RESULTS:
: [1, 0, 3, 2]
: [[1, 'potpaw_PBE/O_h/POTCAR', 1], ['O', 'potpaw_PBE/O_sv/POTCAR', 2], ['H', 'potpaw_PBE/H/POTCAR', 1]]

#+BEGIN_SRC sh
grep TITEL POTCAR
#+END_SRC

#+RESULTS:
:    TITEL  = PAW_PBE O_h 06Feb2004
:    TITEL  = PAW_PBE O_sv 05Jul2007
:    TITEL  = PAW_PBE H 15Jun2001

#+BEGIN_SRC python
import vasp
print vasp.__file__
print dir(vasp)
print vasp.Vasp
#+END_SRC

#+RESULTS:
: ['Calculator', 'FileIOCalculator', 'Vasp', '__builtins__', '__doc__', '__file__', '__name__', '__package__', 'np', 'os']
: vasp/__init__.pyc
: ['Vasp', '__builtins__', '__doc__', '__file__', '__name__', '__package__', '__path__', 'monkeypatch', 'vasp', 'writers']
: vasp.vasp.Vasp

** spin pol

#+BEGIN_SRC python
from vasp import Vasp
from ase import Atom, Atoms

atoms = Atoms([Atom('O', [5, 5, 5], magmom=2), Atom('H', [0, 0 ,0])],
              cell=(10, 10, 10))

calc = Vasp('molecules/O-sp-triplet',
            xc='PBE',
            encut=400,
            ismear=0,
            ispin=2,  # turn spin-polarization on
            atoms=atoms)

calc.write_incar('INCAR')
print open('INCAR').read()

#+END_SRC

#+RESULTS:
: INCAR created by Atomic Simulation Environment
:  MAGMOMS = 2.0 0.0
:  LCHARGE = .FALSE.
:  ENCUT = 400
:  ISPIN = 2
:  ISMEAR = 0
:  LWAVE = .FALSE.
:  SIGMA = 0.1
:

#+BEGIN_SRC python
from vasp import Vasp
from ase import Atom, Atoms

atoms = Atoms([Atom('O', [5, 5, 5], magmom=2), Atom('H', [0, 0 ,0])],
              cell=(10, 10, 10))

calc = Vasp('molecules/O-sp-triplet',
            xc='PBE',
            encut=400,
            ismear=0,
            magmoms=[2, -2],
            ispin=2,  # turn spin-polarization on
            atoms=atoms)

calc.write_incar('INCAR')
print open('INCAR').read()

#+END_SRC

#+RESULTS:
: INCAR created by Atomic Simulation Environment
:  MAGMOMS = 2 -2
:  LCHARGE = .FALSE.
:  ENCUT = 400
:  ISPIN = 2
:  ISMEAR = 0
:  LWAVE = .FALSE.
:  SIGMA = 0.1
:

** DFT+u
#+BEGIN_SRC python
from vasp import Vasp
from ase import Atom, Atoms

a = 4.27

atoms = Atoms([Atom('Cu',[0,0,0]),
               Atom('Cu',[0.5, 0.5, 0.0]),
               Atom('Cu',[0.5, 0.0, 0.5]),
               Atom('Cu',[0.0, 0.5, 0.5]),
               Atom('O',[0.25, 0.25, 0.25]),
               Atom('O',[0.75, 0.75, 0.75])])

atoms.set_cell((a,a,a), scale_atoms=True)

calc =Vasp('Cu2O-U=4.0',
             ldau=True,   # turn DFT+U on
             ldautype=2,  # select simplified rotationally invariant option
             ldau_luj={'Cu':{'L':2,  'U':4.0, 'J':0.0},
                        'O':{'L':-1, 'U':0.0, 'J':0.0}},
             ldauprint=1,
             ibrion=-1,  #do not rerelax
             nsw=0, atoms=atoms)

calc.write_incar('INCAR')
calc.write_poscar('POSCAR')

print calc.ppp_list
print open('INCAR').read()
print open('POSCAR').read()

#+END_SRC

#+RESULTS:
#+begin_example
[['Cu', 'potpaw_PBE/Cu/POTCAR', 4], ['O', 'potpaw_PBE/O/POTCAR', 2]]
INCAR created by Atomic Simulation Environment
 LCHARGE = .FALSE.
 LDAUL = 2 -1
 LDAUU = 4.0 0.0
 LDAUTYPE = 2
 LDAUJ = 0.0 0.0
 LDAU = .TRUE.
 IBRION = -1
 ISMEAR = 1
 LWAVE = .FALSE.
 SIGMA = 0.1
 LDAUPRINT = 1
 NSW = 0

Cu  O
 1.0000000000000000
     4.2699999999999996    0.0000000000000000    0.0000000000000000
     0.0000000000000000    4.2699999999999996    0.0000000000000000
     0.0000000000000000    0.0000000000000000    4.2699999999999996
   4   2
Cartesian
  0.0000000000000000  0.0000000000000000  0.0000000000000000
  2.1349999999999998  2.1349999999999998  0.0000000000000000
  2.1349999999999998  0.0000000000000000  2.1349999999999998
  0.0000000000000000  2.1349999999999998  2.1349999999999998
  1.0674999999999999  1.0674999999999999  1.0674999999999999
  3.2024999999999997  3.2024999999999997  3.2024999999999997

#+end_example

 LDAUL = -1 2
 LDAUU = 0.000 4.000
 LDAUJ = 0.000 0.000

** updaters

#+BEGIN_SRC python
from ase import Atoms, Atom
from vasp import Vasp

import os
os.environ['ASE_VASP_COMMAND'] = '/home-research/zhongnanxu/opt/vasp-5.3.5/bin/vasp-vtst-beef-serial'

#os.system('rm -fr molecules/co')

atoms = Atoms([Atom('C', [4.42,   5., 5.]),
               Atom('O', [5.58,   5., 5.])],
              cell=[10, 10, 10])

print atoms.positions
calc = Vasp('molecules/co', #output dir
            xc='PBE',  # the exchange-correlation functional
            encut=350, # planewave cutoff
            ibrion=2, nsw=10,
            atoms=atoms)
calc.write_input(atoms)
print
print calc.read()

p = calc.parameters

print calc.set(encut=None)
print p
#+END_SRC

#+RESULTS:
: [[ 4.42  5.    5.  ]
:  [ 5.58  5.    5.  ]]
:
: (Atoms(symbols='CO', positions=..., cell=[10.0, 10.0, 10.0], pbc=[True, True, True]), {'pp': 'PBE', 'ibrion': 2, 'xc': 'pbe', 'lcharge': False, 'ismear': 1, 'lwave': False, 'sigma': 0.1, 'kpts': [1, 1, 1], 'encut': 350, 'nsw': 10})
: {'encut': None}
: {'kpts': [1, 1, 1], 'lcharge': False, 'xc': 'pbe', 'pp': 'PBE', 'encut': None, 'ibrion': 2, 'ismear': 1, 'lwave': False, 'sigma': 0.1, 'nsw': 10}

** Idea for validation

#+BEGIN_SRC python
class Float(object):
    def __init__(self, val):
        self.val = val
        assert isinstance(val, float), '{} is not a float'.format(val)

    def __str__(self):
        return '{} = {}'.format(self.__class__.__name__.upper(), self.val)

class INCAR:
    file = 'INCAR'

class sigma(Float, INCAR):
    """SIGMA determines the width of the smearing in eV."""
    pass

print sigma(0.4)  # this is what would get written
print sigma.file  # this is where it would get written
print sigma.__doc__
#+END_SRC

#+RESULTS:
: SIGMA = 0.4
: INCAR
: SIGMA determines the width of the smearing in eV.
* ibz-kpts

#+BEGIN_SRC python
from ase import Atoms, Atom
from vasp import Vasp

co = Atoms([Atom('C', [0, 0, 0]),
            Atom('O', [1.2, 0, 0])],
           cell=(6., 6., 6.))

calc = Vasp('molecules/simple-co',  # output dir
            xc='pbe',  # the exchange-correlation functional
            nbands=6,    # number of bands
            encut=350,    # planewave cutoff
            ismear=1,    # Methfessel-Paxton smearing
            sigma=0.01,  # very small smearing factor for a molecule
            atoms=co)

print('energy = {0} eV'.format(co.get_potential_energy()))
print(co.get_forces())
print calc.get_ibz_k_points()
print calc.get_occupation_numbers()
#+END_SRC

#+RESULTS:
: energy = -14.69111507 eV
: [[ 5.09138064  0.          0.        ]
:  [-5.09138064  0.          0.        ]]
: [[ 0.  0.  0.]]
: [ 2.  2.  2.  2.  2.]


** Al example
#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice import bulk

Al = bulk('Al', 'fcc', a=4.5, cubic=True)
calc = Vasp('bulk/Al-lda-vasp',
            xc='LDA', kpts=[4, 4, 4],
            atoms=Al)

print(calc.get_ibz_k_points())
#+END_SRC

#+RESULTS:
: [[ 0.02777778  0.02777778  0.02777778]
:  [ 0.08333333  0.02777778  0.02777778]
:  [ 0.08333333  0.08333333  0.02777778]
:  [ 0.08333333  0.08333333  0.08333333]]


#+BEGIN_SRC python
from vasp import Vasp

c = Vasp('bulk/Al-lda-vasp')
c.update()
print c.get_occupation_numbers()
#+END_SRC

#+RESULTS:
: [ 1.      1.      1.      1.      0.5576  0.5576  0.5576  0.      0.      0.    ]


#+BEGIN_SRC python
import os
from xml.etree import ElementTree
import numpy as np

with open(os.path.join('bulk/Al-lda-vasp',
                       'vasprun.xml')) as f:
        tree = ElementTree.parse(f)
        # each weight is in a <v>w</v> element in this varray

        print np.array([[float(y) for y in x.text.split()] for x in tree.find("kpoints/varray[@name='kpointlist']")])
#+END_SRC

#+RESULTS:
: [[ 0.125  0.125  0.125]
:  [ 0.375  0.125  0.125]
:  [ 0.375  0.375  0.125]
:  [ 0.375  0.375  0.375]]
* magmoms

#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice.cubic import BodyCenteredCubic

atoms = BodyCenteredCubic(directions=[[1, 0, 0],
                                      [0, 1, 0],
                                      [0, 0, 1]],
                                      size=(1, 1, 1),
                                      symbol='Fe')

for atom in atoms:
    atom.magmom = 0


calc = Vasp('bulk/Fe-bcc-fixedmagmom-{0:1.2f}'.format(0.0),
            xc='PBE',
            encut=300,
            kpts=[4, 4, 4],
            ispin=2,
            nupdown=0,
            atoms=atoms)
#+END_SRC

#+RESULTS:
#+begin_example
energy not in {}. Calc required.
/home-research/jkitchin/kitchin-python/vasp/tests/bulk/Fe-bcc-fixedmagmom-0.00 Queued: 1397213.gilgamesh.cheme.cmu.edu
Job Id: 1397213.gilgamesh.cheme.cmu.edu
    Job_Name = /home-research/jkitchin/kitchin-python/vasp/tests/bulk/Fe-bcc-f
	ixedmagmom-0.00
    Job_Owner = jkitchin@gilgamesh.cheme.cmu.edu
    job_state = R
    queue = short
    server = gilgamesh.cheme.cmu.edu
    Checkpoint = u
    ctime = Thu May 26 08:37:58 2016
    Error_Path = gilgamesh.cheme.cmu.edu:/home-research/jkitchin/kitchin-pytho
	n/vasp/tests/Fe-bcc-fixedmagmom-0.00.e1397213
    exec_host = n27/43
    Hold_Types = n
    Join_Path = oe
    Keep_Files = n
    Mail_Points = a
    mtime = Thu May 26 08:37:59 2016
    Output_Path = gilgamesh.cheme.cmu.edu:/home-research/jkitchin/kitchin-pyth
	on/vasp/tests/bulk/Fe-bcc-fixedmagmom-0.00
    Priority = 0
    qtime = Thu May 26 08:37:58 2016
    Rerunable = True
    Resource_List.mem = 2gb
    Resource_List.neednodes = 1:ppn=1
    Resource_List.nice = 5
    Resource_List.nodect = 1
    Resource_List.nodes = 1:ppn=1
    Resource_List.walltime = 23:00:00
    session_id = 65474
    substate = 42
    Variable_List = PBS_O_HOME=/home-research/jkitchin,PBS_O_LANG=en_US.UTF-8,
	PBS_O_LOGNAME=jkitchin,
	PBS_O_PATH=/opt/kitchingroup/vasp-5.3.5/vtstscripts-914:/home-researc
	h/jkitchin/kitchin-python/ase-jkitchin/tools:/home-research/jkitchin/k
	itchin-python/vasp/bin:/home-research/jkitchin/bin:/opt/kitchingroup/C
	ANOPY/Canopy_64bit/User/bin:/opt/vtk-canopy/bin:/opt/intel/Compiler/11
	.1/072/bin/intel64:/opt/intel/impi/4.0.0.028/intel64/bin:/opt/maui/bin
	:/opt/bin:/usr/local/texlive/2012/bin/x86_64-linux:/usr/lib64/qt-3.3/b
	in:/usr/kerberos/bin:/usr/local/bin:/bin:/usr/bin:/usr/share/pvm3/lib:
	/home-research/jkitchin/anaconda3/bin:/home-research/jkitchin/bin:/hom
	e-research/jkitchin/.rvm/bin,PBS_O_MAIL=/var/spool/mail/jkitchin,
	PBS_O_SHELL=/bin/bash,PBS_O_HOST=gilgamesh.cheme.cmu.edu,
	PBS_SERVER=gilgamesh.cheme.cmu.edu,
	PBS_O_WORKDIR=/home-research/jkitchin/kitchin-python/vasp/tests,
	PBS_O_QUEUE=q_feed
    euser = jkitchin
    egroup = jkitchin
    hashname = 1397213.gilgamesh.cheme.cmu.edu
    queue_rank = 558996
    queue_type = E
    etime = Thu May 26 08:37:58 2016
    submit_args = -o /home-research/jkitchin/kitchin-python/vasp/tests/bulk/Fe
	-bcc-fixedmagmom-0.00 -joe -N /home-research/jkitchin/kitchin-python/v
	asp/tests/bulk/Fe-bcc-fixedmagmom-0.00 -l walltime=23:00:00 -l nodes=1
	:ppn=1 -l mem=2GB
    start_time = Thu May 26 08:37:59 2016
    start_count = 1


Job Id: 1397213.gilgamesh.cheme.cmu.edu
    Job_Name = /home-research/jkitchin/kitchin-python/vasp/tests/bulk/Fe-bcc-f
	ixedmagmom-0.00
    Job_Owner = jkitchin@gilgamesh.cheme.cmu.edu
    job_state = R
    queue = short
    server = gilgamesh.cheme.cmu.edu
    Checkpoint = u
    ctime = Thu May 26 08:37:58 2016
    Error_Path = gilgamesh.cheme.cmu.edu:/home-research/jkitchin/kitchin-pytho
	n/vasp/tests/Fe-bcc-fixedmagmom-0.00.e1397213
    exec_host = n27/43
    Hold_Types = n
    Join_Path = oe
    Keep_Files = n
    Mail_Points = a
    mtime = Thu May 26 08:38:10 2016
    Output_Path = gilgamesh.cheme.cmu.edu:/home-research/jkitchin/kitchin-pyth
	on/vasp/tests/bulk/Fe-bcc-fixedmagmom-0.00
    Priority = 0
    qtime = Thu May 26 08:37:58 2016
    Rerunable = True
    Resource_List.mem = 2gb
    Resource_List.neednodes = 1:ppn=1
    Resource_List.nice = 5
    Resource_List.nodect = 1
    Resource_List.nodes = 1:ppn=1
    Resource_List.walltime = 10:00:00
    session_id = 65474
    substate = 42
    Variable_List = PBS_O_HOME=/home-research/jkitchin,PBS_O_LANG=en_US.UTF-8,
	PBS_O_LOGNAME=jkitchin,
	PBS_O_PATH=/opt/kitchingroup/vasp-5.3.5/vtstscripts-914:/home-researc
	h/jkitchin/kitchin-python/ase-jkitchin/tools:/home-research/jkitchin/k
	itchin-python/vasp/bin:/home-research/jkitchin/bin:/opt/kitchingroup/C
	ANOPY/Canopy_64bit/User/bin:/opt/vtk-canopy/bin:/opt/intel/Compiler/11
	.1/072/bin/intel64:/opt/intel/impi/4.0.0.028/intel64/bin:/opt/maui/bin
	:/opt/bin:/usr/local/texlive/2012/bin/x86_64-linux:/usr/lib64/qt-3.3/b
	in:/usr/kerberos/bin:/usr/local/bin:/bin:/usr/bin:/usr/share/pvm3/lib:
	/home-research/jkitchin/anaconda3/bin:/home-research/jkitchin/bin:/hom
	e-research/jkitchin/.rvm/bin,PBS_O_MAIL=/var/spool/mail/jkitchin,
	PBS_O_SHELL=/bin/bash,PBS_O_HOST=gilgamesh.cheme.cmu.edu,
	PBS_SERVER=gilgamesh.cheme.cmu.edu,
	PBS_O_WORKDIR=/home-research/jkitchin/kitchin-python/vasp/tests,
	PBS_O_QUEUE=q_feed
    euser = jkitchin
    egroup = jkitchin
    hashname = 1397213.gilgamesh.cheme.cmu.edu
    queue_rank = 558996
    queue_type = E
    etime = Thu May 26 08:37:58 2016
    submit_args = -o /home-research/jkitchin/kitchin-python/vasp/tests/bulk/Fe
	-bcc-fixedmagmom-0.00 -joe -N /home-research/jkitchin/kitchin-python/v
	asp/tests/bulk/Fe-bcc-fixedmagmom-0.00 -l walltime=23:00:00 -l nodes=1
	:ppn=1 -l mem=2GB
    start_time = Thu May 26 08:37:59 2016
    start_count = 1


#+end_example


#+BEGIN_SRC python
from vasp import Vasp
calc = Vasp('bulk/Fe-bcc-fixedmagmom-{0:1.2f}'.format(0.0))
print calc.results
print calc.calculation_required()
print calc.check_state()
#+END_SRC

#+RESULTS:
: {'magmom': 0.0, 'stress': array([ 0.15788934,  0.15788934,  0.15788934, -0.        , -0.        , -0.        ]), 'magmoms': array([ 0.,  0.]), 'charges': array([None, None], dtype=object), 'energy': -15.34226703, 'dipole': None, 'forces': array([[ 0.,  0.,  0.],
:        [ 0.,  0.,  0.]])}
: False
: []

** non int nupdown

#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice.cubic import BodyCenteredCubic

NUPDOWNS = [4.0, 4.5, 5.0, 5.5, 6.0]

# These are the same for all calculations.
fixed_pars = dict( xc='PBE',
                   encut=200,
                   kpts=[4, 4, 4],
                   ispin=2,
                   atoms=BodyCenteredCubic(directions=[[1, 0, 0],
                                                       [0, 1, 0],
                                                       [0, 0, 1]],
                                           size=(1, 1, 1),
                                           symbol='Fe'))

# Prepare a list of calculators
calcs = [Vasp('bulk/Fe-bcc-fixedmagmom-{0:1.2f}'.format(B),
              nupdown=B,
              ,**fixed_pars)
         for B in NUPDOWNS]

# This will start each calculation, and if they are not ready abort the script.
# If they are ready, we will get the energies.
energies = Vasp.run()

import matplotlib.pyplot as plt
plt.plot(NUPDOWNS, energies)
plt.xlabel('Total Magnetic Moment')
plt.ylabel('Energy (eV)')
plt.savefig('Fe-fixedmagmom.png')
plt.show()
#+END_SRC

#+RESULTS:



* class calculators

#+BEGIN_SRC python
from vasp import Vasp

NUPDOWNS = [4.0, 4.5, 5.0, 5.5, 6.0]

calcs = [Vasp('bulk/Fe-bcc-fixedmagmom-{0:1.2f}'.format(B))
         for B in NUPDOWNS]

print [calc.ready for calc in Vasp.calculators]
print [calc.check_state() for calc in Vasp.calculators]

print Vasp.all()

Vasp.wait()
#+END_SRC

#+RESULTS:
: [True, True, True, True, True]
: [[], [], [], [], []]
: True
* logging

#+BEGIN_SRC python
from vasp import Vasp
import logging
c = Vasp('test', debug=logging.DEBUG)

log = logging.getLogger('Vasp')
log.debug('t')
log.info('t')
#+END_SRC

#+RESULTS:
: INFO     [[<stdin>::7][<module>]]: t
* xterm

#+BEGIN_SRC python
from vasp import Vasp
calc = Vasp('bulk/Fe-bcc-fixedmagmom-{0:1.2f}'.format(6.0))
calc.xterm()
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calc = Vasp('bulk/Fe-bcc-fixedmagmom-{0:1.2f}'.format(0.0))
calc.qstat()
#+END_SRC

#+RESULTS:
: /home-research/jkitchin/kitchin-python/vasp/tests/bulk/Fe-bcc-fixedmagmom-0.00 not in queue.
